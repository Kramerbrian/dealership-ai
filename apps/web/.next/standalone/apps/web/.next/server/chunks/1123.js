"use strict";exports.id=1123,exports.ids=[1123],exports.modules={17856:(e,t,s)=>{s.d(t,{F:()=>n});var r=s(2381);class i{constructor(){this.cache=new Map,this.cleanupInterval=setInterval(()=>this.cleanup(),3e5)}cleanup(){let e=Date.now();for(let[t,s]of this.cache.entries())e-s.created>1e3*s.ttl&&this.cache.delete(t)}async get(e){let t=this.cache.get(e);return t?Date.now()-t.created>1e3*t.ttl?(this.cache.delete(e),null):t.value:null}async set(e,t,s=3600){this.cache.set(e,{value:t,ttl:s,created:Date.now()})}async del(e){this.cache.delete(e)}async exists(e){let t=this.cache.get(e);return!!t&&(!(Date.now()-t.created>1e3*t.ttl)||(this.cache.delete(e),!1))}async flush(){this.cache.clear()}destroy(){clearInterval(this.cleanupInterval),this.cache.clear()}}class o{constructor(){this.connected=!1,this.initRedis()}async initRedis(){try{if(!process.env.REDIS_URL){r.kg.info("No Redis URL provided, skipping Redis initialization");return}let e=(await s.e(57).then(s.t.bind(s,60057,23))).default;this.redis=new e(process.env.REDIS_URL),this.redis.on("connect",()=>{this.connected=!0,r.kg.info("Redis connected")}),this.redis.on("error",e=>{this.connected=!1,r.kg.error("Redis error",e)}),await this.redis.ping(),this.connected=!0}catch(e){r.kg.warn("Failed to initialize Redis, using in-memory cache",{error:e}),this.connected=!1}}async get(e){if(!this.connected||!this.redis)return null;try{let t=await this.redis.get(e);return t?JSON.parse(t):null}catch(e){return r.kg.error("Redis get error",e instanceof Error?e:Error(String(e))),null}}async set(e,t,s=3600){if(this.connected&&this.redis)try{await this.redis.setex(e,s,JSON.stringify(t))}catch(e){r.kg.error("Redis set error",e instanceof Error?e:Error(String(e)))}}async del(e){if(this.connected&&this.redis)try{await this.redis.del(e)}catch(e){r.kg.error("Redis del error",e instanceof Error?e:Error(String(e)))}}async exists(e){if(!this.connected||!this.redis)return!1;try{let t=await this.redis.exists(e);return 1===t}catch(e){return r.kg.error("Redis exists error",e instanceof Error?e:Error(String(e))),!1}}async flush(){if(this.connected&&this.redis)try{await this.redis.flushall()}catch(e){r.kg.error("Redis flush error",e instanceof Error?e:Error(String(e)))}}}class a{constructor(){this.redis=new o,this.memory=new i}async get(e){let t=await this.redis.get(e);return null!==t?t:t=await this.memory.get(e)}async set(e,t,s=3600){await Promise.all([this.redis.set(e,t,s),this.memory.set(e,t,s)])}async del(e){await Promise.all([this.redis.del(e),this.memory.del(e)])}async exists(e){return!!await this.redis.exists(e)||await this.memory.exists(e)}async flush(){await Promise.all([this.redis.flush(),this.memory.flush()])}async remember(e,t,s=3600){let r=await this.get(e);if(null!==r)return r;let i=await t();return await this.set(e,i,s),i}async mget(e){return Promise.all(e.map(e=>this.get(e)))}async mset(e){await Promise.all(e.map(({key:e,value:t,ttl:s=3600})=>this.set(e,t,s)))}key(e,...t){return`dealershipai:${e}:${t.join(":")}`}dealerKey(e,...t){return this.key("dealer",e,...t)}scoreKey(e,t){return this.dealerKey(e,"scores",t)}batchKey(e,...t){return this.key("batch",e,...t)}queueKey(...e){return this.key("queue",...e)}}let n=new a},2381:(e,t,s)=>{s.d(t,{hu:()=>o,kg:()=>i});class r{constructor(){this.level=process.env.LOG_LEVEL||"info",this.format=process.env.LOG_FORMAT||"json"}shouldLog(e){let t=["debug","info","warn","error"];return t.indexOf(e)>=t.indexOf(this.level)}formatLog(e){if("json"===this.format)return JSON.stringify({...e,error:e.error?{name:e.error.name,message:e.error.message,stack:e.error.stack}:void 0});let t=`[${e.timestamp}] ${e.level.toUpperCase()}`,s=e.context?` ${JSON.stringify(e.context)}`:"",r=e.error?`
${e.error.stack}`:"";return`${t}: ${e.message}${s}${r}`}log(e,t,s,r){if(!this.shouldLog(e))return;let i={level:e,message:t,timestamp:new Date().toISOString(),context:s,error:r},o=this.formatLog(i);"error"===e?console.error(o):"warn"===e?console.warn(o):console.log(o)}debug(e,t){this.log("debug",e,t)}info(e,t){this.log("info",e,t)}warn(e,t){this.log("warn",e,t)}error(e,t,s){this.log("error",e,s,t)}apiRequest(e,t,s,r){this.info("API Request",{method:e,path:t,status:s,duration_ms:r})}queueJob(e,t,s,r){let i={jobId:e,type:t,...r&&{duration_ms:r}};"failed"===s?this.error(`Queue job ${s}`,void 0,i):this.info(`Queue job ${s}`,i)}costAlert(e,t,s){this.warn("Cost threshold exceeded",{amount:e,threshold:t,period:s,excess:e-t})}}let i=new r;function o(e){let t=new r,s=t.log;return t.log=function(t,r,i,o){let a=`[${e}] ${r}`;return s.call(this,t,a,i,o)},t}},11123:(e,t,s)=>{s.d(t,{c:()=>a});var r=s(2381),i=s(17856);class o{constructor(e={}){this.jobs=new Map,this.processors=new Map,this.processing=new Set,this.isRunning=!1,this.metrics={processedJobs:0,totalProcessingTime:0,startTime:Date.now()},this.options={concurrency:e.concurrency||parseInt(process.env.QUEUE_CONCURRENCY||"5"),defaultPriority:e.defaultPriority||"normal",defaultMaxAttempts:e.defaultMaxAttempts||3,jobTimeout:e.jobTimeout||3e5},this.start(),setInterval(()=>this.cleanup(),36e5)}registerProcessor(e,t){this.processors.set(e,t),r.kg.info("Job processor registered",{jobType:e})}async add(e,t,s={}){let o=`job_${Date.now()}_${Math.random().toString(36).substring(7)}`,a={id:o,type:e,payload:t,status:"pending",priority:s.priority||this.options.defaultPriority,attempts:0,maxAttempts:s.maxAttempts||this.options.defaultMaxAttempts,createdAt:new Date,metadata:s.metadata||{}};return this.jobs.set(o,a),await i.F.set(i.F.queueKey("job",o),a,86400),r.kg.info("Job added to queue",{jobId:o,type:e,priority:a.priority,queueSize:this.jobs.size}),this.isRunning||this.start(),o}async get(e){let t=this.jobs.get(e);return!t&&(t=await i.F.get(i.F.queueKey("job",e)))&&this.jobs.set(e,t),t||null}async cancel(e){let t=await this.get(e);return!!t&&"pending"===t.status&&(t.status="cancelled",t.completedAt=new Date,await i.F.set(i.F.queueKey("job",e),t,86400),r.kg.info("Job cancelled",{jobId:e}),!0)}async retry(e){let t=await this.get(e);return!!t&&"failed"===t.status&&(t.status="pending",t.attempts=0,t.error=void 0,t.startedAt=void 0,t.completedAt=void 0,await i.F.set(i.F.queueKey("job",e),t,86400),r.kg.info("Job retried",{jobId:e}),!0)}start(){this.isRunning||(this.isRunning=!0,this.processJobs(),r.kg.info("Queue processing started",{concurrency:this.options.concurrency}))}stop(){this.isRunning=!1,r.kg.info("Queue processing stopped")}async processJobs(){for(;this.isRunning;)try{if(this.processing.size>=this.options.concurrency){await new Promise(e=>setTimeout(e,1e3));continue}let e=this.getNextJob();if(!e){await new Promise(e=>setTimeout(e,1e3));continue}this.processJob(e)}catch(e){r.kg.error("Queue processing error",e instanceof Error?e:Error(String(e))),await new Promise(e=>setTimeout(e,5e3))}}getNextJob(){return Array.from(this.jobs.values()).filter(e=>"pending"===e.status).sort((e,t)=>{let s={urgent:4,high:3,normal:2,low:1},r=s[t.priority]-s[e.priority];return 0!==r?r:e.createdAt.getTime()-t.createdAt.getTime()})[0]||null}async processJob(e){let t=this.processors.get(e.type);if(!t){e.status="failed",e.error=`No processor registered for job type: ${e.type}`,e.completedAt=new Date,await i.F.set(i.F.queueKey("job",e.id),e,86400);return}this.processing.add(e.id),e.status="processing",e.startedAt=new Date,e.attempts++,await i.F.set(i.F.queueKey("job",e.id),e,86400),r.kg.info("Job processing started",{jobId:e.id,type:e.type,attempt:e.attempts});try{let s=new Promise((e,t)=>setTimeout(()=>t(Error("Job timeout")),this.options.jobTimeout)),i=await Promise.race([t(e),s]);e.status="completed",e.result=i,e.completedAt=new Date;let o=e.completedAt.getTime()-e.startedAt.getTime();this.metrics.processedJobs++,this.metrics.totalProcessingTime+=o,r.kg.info("Job completed successfully",{jobId:e.id,type:e.type,processingTime:o})}catch(s){let t=s instanceof Error?s.message:String(s);e.attempts>=e.maxAttempts?(e.status="failed",e.error=t,e.completedAt=new Date,r.kg.error("Job failed permanently",s instanceof Error?s:Error(String(s)),{jobId:e.id,type:e.type,attempts:e.attempts})):(e.status="pending",e.startedAt=void 0,r.kg.warn("Job failed, will retry",{jobId:e.id,type:e.type,attempt:e.attempts,maxAttempts:e.maxAttempts,error:t}))}finally{this.processing.delete(e.id),await i.F.set(i.F.queueKey("job",e.id),e,86400)}}async getMetrics(){let e=Array.from(this.jobs.values()),t=e.filter(e=>"pending"===e.status).length,s=e.filter(e=>"processing"===e.status).length,r=e.filter(e=>"completed"===e.status).length,i=e.filter(e=>"failed"===e.status).length,o=this.metrics.processedJobs>0?this.metrics.totalProcessingTime/this.metrics.processedJobs:void 0,a=(Date.now()-this.metrics.startTime)/36e5,n=a>0?this.metrics.processedJobs/a:void 0;return{pending:t,processing:s,completed:r,failed:i,total:e.length,avgProcessingTime:o,throughputPerHour:n}}async listJobs(e={}){let t=Array.from(this.jobs.values());e.status&&(t=t.filter(t=>t.status===e.status)),e.type&&(t=t.filter(t=>t.type===e.type)),t.sort((e,t)=>t.createdAt.getTime()-e.createdAt.getTime());let s=e.offset||0,r=e.limit||50;return t.slice(s,s+r)}async getJobsByStatus(e){return this.listJobs({status:e})}async cleanup(){let e=new Date;e.setHours(e.getHours()-24);let t=Array.from(this.jobs.values()).filter(t=>("completed"===t.status||"failed"===t.status)&&t.completedAt&&t.completedAt<e);for(let e of t)this.jobs.delete(e.id),await i.F.del(i.F.queueKey("job",e.id));t.length>0&&r.kg.info("Cleaned up old jobs",{count:t.length})}async pause(){this.isRunning=!1,r.kg.info("Queue paused")}async resume(){this.start(),r.kg.info("Queue resumed")}async clear(e){let t=Array.from(this.jobs.values());for(let s of(e&&(t=t.filter(t=>t.status===e)),t))this.jobs.delete(s.id),await i.F.del(i.F.queueKey("job",s.id));return r.kg.info("Queue cleared",{count:t.length,status:e||"all"}),t.length}}let a=new o}};